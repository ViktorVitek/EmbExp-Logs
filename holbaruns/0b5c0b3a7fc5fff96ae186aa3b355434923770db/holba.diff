diff --git a/src/tools/scamv/bir_embexp_driverLib.sig b/src/tools/scamv/bir_embexp_driverLib.sig
index ce36e6f..02f8023 100644
--- a/src/tools/scamv/bir_embexp_driverLib.sig
+++ b/src/tools/scamv/bir_embexp_driverLib.sig
@@ -1,6 +1,25 @@
 signature bir_embexp_driverLib = sig
 
-  val bir_embexp_create : (string * (string * string)) -> string -> (((string * num) list) * ((string * num) list)) -> string
+  (* Inputs:
+       - (architecture_id, prog_gen_id)
+       - asm_lines
+     Returns id of program entry (prog_id)
+   *)
+  val bir_embexp_prog_create : (string * string) -> string list -> string
+
+  (* Inputs:
+       - (architecture_id, experiment_type_id/attacker_id, state_gen_id/obs_model_id)
+       - prog_id (see above)
+       - (state1, state2)
+     Returns experiment id (exp_id)
+   *)
+  val bir_embexp_sates2_create : (string * string * string) -> string -> (((string * num) list) * ((string * num) list)) -> string
+
+  (* Inputs:
+       - exp_id (see above)
+       - with_reset (run with reset or not)
+     Returns (maybe result, comment)
+   *)
   val bir_embexp_run : string -> bool -> (bool option * string)
 
 end
diff --git a/src/tools/scamv/bir_embexp_driverLib.sml b/src/tools/scamv/bir_embexp_driverLib.sml
index 71a6829..d91c41d 100644
--- a/src/tools/scamv/bir_embexp_driverLib.sml
+++ b/src/tools/scamv/bir_embexp_driverLib.sml
@@ -3,6 +3,8 @@ struct
 
   open HolKernel Parse boolLib bossLib;
 
+  open bir_prog_genLib;
+
 (* error handling *)
   val libname = "bir_embexp_driverLib"
   val ERR = Feedback.mk_HOL_ERR libname
@@ -41,6 +43,10 @@ struct
         NONE =>
           let
             val dir_path = logfile_basedir_read();
+            val _ = if not (OS.FileSys.isDir dir_path) then
+                      raise ERR "logfile_basedir" ("not a directory: " ^ dir_path)
+                    else
+                      ();
             val _ = logfile_basedir_ref := SOME dir_path;
           in
             dir_path
@@ -52,25 +58,11 @@ struct
   fun get_datestring () =
     let
       val date = Date.fromTimeLocal (Time.now ());
-      val datestr = Date.fmt "%Y-%m-%d_%H-%M-%S_" date;
+      val datestr = Date.fmt "%Y-%m-%d_%H-%M-%S" date;
     in
       datestr
     end;
 
-
-(* embexp run identification *)
-  val embexp_run_id_ref = ref (NONE:string option);
-  fun embexp_run_id () =
-    case !embexp_run_id_ref of
-        NONE =>
-          let
-            val datestr = get_datestring();
-            val _ = embexp_run_id_ref := SOME datestr;
-          in
-            datestr
-          end
-      | SOME p => p;
-
 (* directory creation helper *)
   fun makedir makepath path =
     let
@@ -83,20 +75,26 @@ struct
       ()
     end;
 
-(* helper functions *)
-  fun get_experiment_basedir (arch_name, exp_name) =
+(* log dir helper functions *)
+  fun get_progs_basedir arch_name =
     let
       val logfile_basedir_p = logfile_basedir()
-      val _ = if not (OS.FileSys.isDir logfile_basedir_p) then
-                raise ERR "logfile_basedir" ("not a directory: " ^ logfile_basedir_p)
-              else
-                ();
-      val exp_basedir = logfile_basedir_p ^ "/" ^ arch_name ^ "/" ^ exp_name;
+      val progs_basedir = logfile_basedir_p ^ "/" ^ arch_name ^ "/progs";
+      val _ = makedir true progs_basedir;
+    in
+      progs_basedir
+    end;
+
+  fun get_experiment_basedir arch_name =
+    let
+      val logfile_basedir_p = logfile_basedir()
+      val exp_basedir = logfile_basedir_p ^ "/" ^ arch_name;
       val _ = makedir true exp_basedir;
     in
       exp_basedir
     end;
 
+(* file read/write helpers *)
   fun read_from_file filename =
     let
       val file = TextIO.openIn filename;
@@ -132,13 +130,22 @@ struct
     in
       str = s
     end;
+  fun write_to_file_or_compare_clash clash_id filename str =
+    let
+      val eq = write_to_file_or_compare filename str;
+      val _ = if eq then () else
+                raise ERR ("write_to_file_or_compare_clash___" ^ clash_id) ("there has been a clash with: " ^ filename);
+    in
+      ()
+    end;
 
+(* helper functions *)
   val tempdir = "./tempdir";
   fun get_tempfile prefix suffix =
     let
       val _ = makedir true tempdir;
       val datestr = get_datestring();
-      val tempfile = tempdir ^ "/" ^ prefix ^ "_" ^ datestr ^ suffix;
+      val tempfile = tempdir ^ "/" ^ prefix ^ "_" ^ datestr ^ "_" ^ suffix;
     in
       tempfile
     end;
@@ -211,6 +218,41 @@ struct
       get_exec_python3_argvar (pyhashprep ^ pyprint) str
     end;
 
+(* embexp run identification *)
+  val embexp_run_id_ref = ref (NONE:string option);
+  fun embexp_run_id () =
+    case !embexp_run_id_ref of
+        NONE =>
+          let
+            val logfile_basedir_p = logfile_basedir()
+	    val holbaruns_basedir = logfile_basedir_p ^ "/holbaruns";
+	    val _ = makedir true holbaruns_basedir;
+
+            (* write out git commit and git diff of current directory. *)
+            (*    so this script needs to be executed from within the holbarepo! *)
+            val run_datestr = get_datestring();
+	    val holba_diff = get_exec_output "git diff";
+	    val holba_commit = get_exec_output "git rev-parse HEAD";
+
+	    val holba_hash = hashstring (run_datestr ^ holba_diff ^ holba_commit);
+	    val runitpath = holbaruns_basedir ^ "/" ^ holba_hash;
+	    (* this directory should not exist, but possibly already exists *)
+	    val _ = makedir true runitpath;
+
+	    val run_datestr_file = runitpath ^ "/holba.time";
+	    val holba_diff_file = runitpath ^ "/holba.diff";
+	    val holba_commit_file = runitpath ^ "/holba.commit";
+
+	    val _ = write_to_file_or_compare_clash "embexp_run_id" run_datestr_file run_datestr;
+	    val _ = write_to_file_or_compare_clash "embexp_run_id" holba_diff_file holba_diff;
+	    val _ = write_to_file_or_compare_clash "embexp_run_id" holba_commit_file holba_commit;
+
+            val _ = embexp_run_id_ref := SOME holba_hash;
+          in
+            holba_hash
+          end
+      | SOME p => p;
+
 
 (* create json state *)
   fun gen_json_state isSecond s =
@@ -237,62 +279,59 @@ struct
     end;
 
 (* interface functions *)
-  fun bir_embexp_create (obs_model_name, exp_id) exp_code_asm (s1,s2) =
+  fun bir_embexp_prog_create (arch_id, prog_gen_id) asm_lines =
     let
-      val exp_basedir = get_experiment_basedir exp_id;
+      val progs_basedir = get_progs_basedir arch_id;
+      val code_asm = bir_prog_gen_asm_lines_to_code asm_lines;
 
       (* write out code *)
-      val exp_codehash = hashstring exp_code_asm;
-      val exp_codepath = exp_basedir ^ "/" ^ exp_codehash;
+      val codehash = hashstring code_asm;
+      val codepath = progs_basedir ^ "/" ^ codehash;
       (* this directory possibly already exists *)
-      val _ = makedir true exp_codepath;
+      val _ = makedir true codepath;
       (* but the code should not differ if it exists already *)
-      val code_eq = write_to_file_or_compare (exp_codepath ^ "/code.asm") exp_code_asm;
-      val _ = if code_eq then () else
-                raise ERR "bir_embexp_create" ("there has been a hash clash with: " ^ exp_codepath);
+      val _ = write_to_file_or_compare_clash "bir_embexp_prog_create" (codepath ^ "/code.asm") code_asm;
+
+      (* write out gen info *)
+      val embexp_run_file = codepath ^ "/" ^ (embexp_run_id()) ^ "." ^ (get_datestring ());
+      val _ = write_to_file_or_compare_clash "bir_embexp_prog_create" embexp_run_file prog_gen_id;
+    in
+      codehash
+    end;
+
+  fun bir_embexp_sates2_create (arch_id, exp_type_id, state_gen_id) prog_id (s1,s2) =
+    let
+      val exp_basedir = get_experiment_basedir arch_id;
 
       (* write out data *)
       val input1 = gen_json_state false s1;
       val input2 = gen_json_state true  s2;
-      val exp_datahash = hashstring (input1 ^ input2);
-      val exp_datapath = exp_codepath ^ "/" ^ exp_datahash;
+      val exp_datahash = hashstring (prog_id ^ input1 ^ input2);
+      val exp_id = "exps2/" ^ exp_type_id ^ "/" ^ exp_datahash;
+      val exp_datapath = exp_basedir ^ "/" ^ exp_id;
       (* it can also happen that the same test is produced multiple times *)
       val _ = makedir true exp_datapath;
-      val input1_eq = write_to_file_or_compare (exp_datapath ^ "/input1.json") input1;
-      val input2_eq = write_to_file_or_compare (exp_datapath ^ "/input2.json") input2;
-      val _ = if input1_eq andalso input2_eq then () else
-                raise ERR "bir_embexp_create" ("there has been a hash clash with: " ^ exp_datapath);
-
-      (* write out git commit and git diff of current directory. so this script needs to be executed from within the holbarepo! *)
-      val embexp_run_id = embexp_run_id();
-      val holba_diff = get_exec_output "git diff";
-      val holba_commit = get_exec_output "git rev-parse HEAD";
-      val holba_diff_file = exp_datapath ^ "/holba_" ^ embexp_run_id ^ ".diff";
-      val holba_commit_file = exp_datapath ^ "/holba_" ^ embexp_run_id ^ ".commit";
-      val holba_obsmodel_file = exp_datapath ^ "/holba_" ^ embexp_run_id ^ ".obsmodel";
-
-      val holba_diff_eq = write_to_file_or_compare holba_diff_file holba_diff;
-      val _ = if holba_diff_eq then () else
-                raise ERR "bir_embexp_create" ("there has been a clash with: " ^ holba_diff_file);
-
-      val holba_commit_eq = write_to_file_or_compare holba_commit_file holba_commit;
-      val _ = if holba_commit_eq then () else
-                raise ERR "bir_embexp_create" ("there has been a clash with: " ^  holba_commit_file);
-
-      val holba_obsmodel_eq = write_to_file_or_compare holba_obsmodel_file obs_model_name;
-      val _ = if holba_obsmodel_eq then () else
-                raise ERR "bir_embexp_create" ("there has been a clash with: " ^ holba_obsmodel_file);
+      val _ = write_to_file_or_compare_clash "bir_embexp_sates2_create" (exp_datapath ^ "/input1.json") input1;
+      val _ = write_to_file_or_compare_clash "bir_embexp_sates2_create" (exp_datapath ^ "/input2.json") input2;
+
+      (* write out reference to the code (hash of the code) *)
+      val prog_id_file = exp_datapath ^ "/code.hash";
+      val _ = write_to_file_or_compare_clash "bir_embexp_sates2_create" prog_id_file prog_id;
+
+      (* write out gen info *)
+      val embexp_run_file = exp_datapath ^ "/" ^ (embexp_run_id()) ^ "." ^ (get_datestring ());
+      val _ = write_to_file_or_compare_clash "bir_embexp_prog_create" embexp_run_file state_gen_id;
     in
-      exp_datapath
+      arch_id ^ "/" ^ exp_id
     end;
 
 
-  fun bir_embexp_run exp_path with_reset =
+  fun bir_embexp_run exp_id with_reset =
     if with_reset then (NONE, "not implemented yet") else
     let
       val cmdline = ("\"" ^ (logfile_basedir()) ^ "/scripts/run_experiment.py\" " ^
                      "\"" ^ (embexp_basedir()) ^ "\" " ^
-                     "\"" ^ exp_path ^ "\" ");
+                     exp_id);
       val lines = get_exec_output_list cmdline;
       val lastline = List.nth(lines, (List.length lines) - 1);
       val result = if lastline = "result = true\n" then
diff --git a/src/tools/scamv/bir_scamv_driverLib.sig b/src/tools/scamv/bir_scamv_driverLib.sig
index 010e62d..ffda821 100644
--- a/src/tools/scamv/bir_scamv_driverLib.sig
+++ b/src/tools/scamv/bir_scamv_driverLib.sig
@@ -8,8 +8,6 @@ signature bir_scamv_driverLib = sig
 
   val scamv_test_mock : unit -> (bool option * string)
 
-  val scamv_test_asmf : string -> (bool option * string)
-
   val scamv_run : scamv_config -> unit
 
 end
diff --git a/src/tools/scamv/bir_scamv_driverLib.sml b/src/tools/scamv/bir_scamv_driverLib.sml
index e522ed9..2fdc6b0 100644
--- a/src/tools/scamv/bir_scamv_driverLib.sml
+++ b/src/tools/scamv/bir_scamv_driverLib.sml
@@ -84,30 +84,22 @@ fun lift_program_from_sections sections =
         lifted_prog_typed
     end
 
-fun process_asm_code asm_code =
+fun process_asm_lines prog_gen_id asm_lines =
     let
+        val prog_id = bir_embexp_prog_create ("arm8", prog_gen_id) asm_lines
+        val asm_code = bir_prog_gen_asm_lines_to_code asm_lines
         val da_file = bir_gcc_assembe_disassemble asm_code "./tempdir"
 
         val (region_map, sections) = read_disassembly_file_regions da_file;
     in
-        (asm_code, sections)
-    end
-
-fun prog_gen_from_file s_file =
-    let
-        val file = TextIO.openIn s_file;
-        val s    = TextIO.inputAll file before TextIO.closeIn file;
-
-        val asm_code = s; 
-    in
-        process_asm_code asm_code
+        (prog_id, sections)
     end
 
 fun prog_gen_mock () =
     let
-        val asm_code = bir_prog_gen_asm_lines_to_code (bir_prog_gen_arm8_mock ())
+        val asm_lines = bir_prog_gen_arm8_mock ()
     in
-        process_asm_code asm_code
+        process_asm_lines "prog_gen_mock" asm_lines
     end
 
 fun symb_exec_phase prog =
@@ -218,7 +210,7 @@ fun print_model model =
 fun to_sml_Arbnums model =
     List.map (fn (name, tm) => (name, dest_word_literal tm)) model;
 
-val (current_asm : string ref) = ref "";
+val (current_prog_id : string ref) = ref "";
 val (current_prog : term option ref) = ref NONE;
 val (current_pathstruct :
      (term * (term * term) list option) list ref) = ref [];
@@ -226,7 +218,7 @@ val (current_word_rel : term option ref) = ref NONE;
 val (current_antecedents : term list ref) = ref [];
 
 fun reset () =
-    (current_asm := "";
+    (current_prog_id := "";
      current_prog := NONE;
      current_pathstruct := [];
      current_word_rel := NONE;
@@ -234,8 +226,8 @@ fun reset () =
 
 fun start_interactive prog =
     let
-        val (asm_file_contents, sections) = prog;
-        val _ = current_asm := asm_file_contents;
+        val (prog_id, sections) = prog;
+        val _ = current_prog_id := prog_id;
         val lifted_prog = lift_program_from_sections sections;
         val _ = current_prog := SOME lifted_prog;
 
@@ -267,7 +259,7 @@ fun next_test select_path =
         val sml_model = to_sml_Arbnums model;
         fun isPrimedRun s = String.isSuffix "_" s;
         val (s2,s1) = List.partition (isPrimedRun o fst) sml_model;
-        val asm_file_contents = !current_asm;
+        val prog_id = !current_prog_id;
 
         fun mk_var_mapping s =
             let fun mk_eq (a,b) =
@@ -282,9 +274,9 @@ fun next_test select_path =
         val _ = current_word_rel := SOME ``^rel /\ ~^(mk_var_mapping model)``;
 
         val _ = print_term (valOf (!current_word_rel));
-        
-        val exp_path = bir_embexp_create ("obs_model_name_here", ("arm8", "exp_cache_multiw")) asm_file_contents (s1, s2);
-        val test_result = bir_embexp_run exp_path false;
+
+        val exp_id  =  bir_embexp_sates2_create ("arm8", "exp_cache_multiw", "obs_model_name_here") prog_id (s1, s2);
+        val test_result = bir_embexp_run exp_id false;
 
         val _ = case test_result of
 		   (NONE, msg) => print ("result = NO RESULT (" ^ msg ^ ")")
@@ -324,10 +316,10 @@ fun scamv_test_main tests prog =
 
 (*
 val _ = bir_prog_gen_arm8_mock_set [["subs w12, w12, w15, sxtb #1"]];
-val (asm_code, sections) = prog_gen_mock ();
-val (asm_code, sections) = process_asm_code (bir_prog_gen_asm_lines_to_code (bir_prog_gen_arm8_rand 5));
+val (asm_lines, sections) = prog_gen_mock ();
+val (asm_lines, sections) = process_asm_lines "interactive_test" (bir_prog_gen_arm8_rand 5);
 *)
-fun scamv_test_gen_run tests (asm_code, sections) =
+fun scamv_test_gen_run tests (prog_id, sections) =
     let
         val lifted_prog = lift_program_from_sections sections;
         val lifted_prog_w_obs =
@@ -349,8 +341,8 @@ fun scamv_test_gen_run tests (asm_code, sections) =
         fun isPrimedRun s = String.isSuffix "_" s;
         val (s2,s1) = List.partition (isPrimedRun o fst) sml_model;
 
-        val exp_path = bir_embexp_create ("obs_model_name_here", ("arm8", "exp_cache_multiw")) asm_code (s1, s2);
-        val test_result = bir_embexp_run exp_path false;
+        val exp_id  =  bir_embexp_sates2_create ("arm8", "exp_cache_multiw", "obs_model_name_here") prog_id (s1, s2);
+        val test_result = bir_embexp_run exp_id false;
 
         val _ = case test_result of
 		   (NONE, msg) => print ("result = NO RESULT (" ^ msg ^ ")")
@@ -362,7 +354,6 @@ fun scamv_test_gen_run tests (asm_code, sections) =
     end
 
 val scamv_test_mock = scamv_test_gen_run 1 o prog_gen_mock;
-val scamv_test_asmf = scamv_test_gen_run 1 o prog_gen_from_file;
 
 type scamv_config = { max_iter : int, prog_size : int, max_tests : int }
 
@@ -371,16 +362,16 @@ fun scamv_run { max_iter = m, prog_size = sz, max_tests = tests } =
 
         val _ = bir_prog_gen_arm8_mock_set_wrap_around true;
 
-        fun prog_gen_fun () =
+        val (prog_gen_fun, prog_gen_id) =
           if is_mock then
-            bir_prog_gen_arm8_mock ()
+            (fn () => bir_prog_gen_arm8_mock (), "prog_gen_mock")
           else
-            bir_prog_gen_arm8_rand sz;
+            (fn () => bir_prog_gen_arm8_rand sz, "prog_gen_rand");
         
         fun main_loop 0 = ()
          |  main_loop n =
             let val prog =
-                    process_asm_code (bir_prog_gen_asm_lines_to_code (prog_gen_fun ()))
+                    process_asm_lines prog_gen_id (prog_gen_fun ())
             in scamv_test_main tests prog; main_loop (n-1) end
     in
         main_loop m
